//
// Created by Svain on 2022/7/22.
//

#ifndef FASTWEBSERVER_PACKER_H
#define FASTWEBSERVER_PACKER_H

#include <cassert>
#include <cstddef>
#include <cstring>
#include <cstdint>
#include <type_traits>

#include "Portability.h"

using namespace std;

/* To pack/unpack for integer value with the fewest number of bytes (compress), but no compress for float and string.
 * Check the integer and determine the bytes number for storing, and bytes number and the sign bit will be store in a
 * 4-bit code called by nibble. The nibble will be generated by the pack() and passed back by the unpack().
 * The pack()/unpack() will only correct on little-endian machines.
 * The pack()/unpack() require the caller to explicitly specify the type of variable. The nanolog system will encode the
 * types directly into generated code.
 * The value of the special code S represents by :
 * 0                        -> 16-byte value
 * [1, sizeof(T)]           -> S bytes integer
 * [9, 8+sizeof(T)]         -> S-8 bytes negative integer
*/

// TODO To encode number deltas instead of smallest value is best for log metrics with monotonically increasing (numbers)

namespace NanologBufferUtil {

    // Pack two 4 bits nibbles into 1 bytes.
    NANOLOG_PACK_PUSH struct pack_two_nibbles {
        uint8_t first:4;
        uint8_t second:4;
    }; NANOLOG_PACK_POP

    // Pack an unsigned integer and a char array, determine the fewest byte number of the integer and copy that into char array.
    template<typename T>
    inline typename enable_if<is_integral<T>::value && !is_signed<T>::value, int>::type
    // binary search for the fewest bytes container to store integer.
    pack(char **buffer, T value) {
        int num_bytes = 0;
        if (value < (1UL << 8)) {
            num_bytes = 1;
        }
        else if (value < (1UL << 16)) {
            num_bytes = 2;
        }
        else if (value < (1UL << 24)) {
            num_bytes = 3;
        }
        else if (value < (1UL << 32)) {
            num_bytes = 4;
        }
        else if (value < (1UL << 40)) {
            num_bytes = 5;
        }
        else if (value < (1UL << 48)) {
            num_bytes = 6;
        }
        else if (value < (1UL << 56)) {
            num_bytes = 7;
        }
        else {
            num_bytes = 8;
        }
        memcpy(*buffer, &value, sizeof(T));
        *buffer += num_bytes;
        return num_bytes;
    }

    // pack() for packing a signed integer into the unsigned version
    inline int pack(char **buffer, int32_t value) {
        if (value >= 0 || value <= int32_t(-(1<<24))) return pack<uint32_t>(buffer, static_cast<uint32_t>(value));
        else return 8 + pack<uint32_t>(buffer, static_cast<uint32_t>(-value));
    }

    inline


}


#endif //FASTWEBSERVER_PACKRE_H
